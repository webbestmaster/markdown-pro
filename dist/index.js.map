{"version":3,"file":"index.js","mappings":"mBACA,ICCYA,EDDRC,EAAsB,CEA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFV,EAAyBC,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,GAAO,G,yLHH9D,SAAYjB,GACRA,EAAA,YACAA,EAAA,YACAA,EAAA,aACH,CAJD,CAAYA,IAAAA,EAAa,KAMlB,MAAMkB,EAA4C,CACrDC,cAAeA,CAACC,EAAkBC,IACvBA,EAEXC,WAAW,EACXC,UAAWvB,EAAcwB,KACzBC,cAAc,EACdC,YAAY,EACZC,iBAAkB,UAGTC,EAAmD,CAC5D,CAAC5B,EAAcwB,MAAO,GAAGN,EAAsBS,0BAA0B3B,EAAcwB,OACvF,CAACxB,EAAc6B,MAAO,GAAGX,EAAsBS,0BAA0B3B,EAAc6B,OACvF,CAAC7B,EAAc8B,OAAQ,GAAGZ,EAAsBS,0BAA0B3B,EAAc8B,SAG/EC,EAAa,UIvBpB,SAAUC,EAAyBC,GACrC,MAAO,kBAAkBC,KAAKD,EAClC,CAEM,SAAUE,EAAgBC,EAAYC,GACxC,OAAOA,EAAKC,MAAMC,GACPA,EAASH,KAAOA,GAE/B,CAEM,SAAUI,EAA6BC,GACzC,OAAOA,EAAMC,MAAM,GAAI,GAAGC,MAC9B,CAGM,SAAUC,EAAkBH,GAE9B,OAAOD,EAA6BC,GAAOI,cAAcC,QAAQ,OAAQ,KAAKH,OAAOG,QAAQ,QAAS,IAC1G,CCpBO,MAAMC,EAAc,GACdC,EAAQ,IACRC,EAAe,QCAfC,EAAiE,CAC1EC,OAAQ,SACR,MAAS,SAKAC,EAA+B,oCCL5C,SAASC,EAAgBZ,GACrB,MAAML,EAAKQ,EAAkBH,GACvBa,EAAoBd,EAA6BC,GAEvD,OAA4B,IAAxBA,EAAMc,QAAQ,MACP,CACHC,oBAAqB,KACrBpB,KACAkB,oBACAG,KAAMP,EAAgBQ,OAIvB,CACHF,oBAAqB,KACrBpB,KACAkB,oBACAG,KAAMP,EAAgBC,OAE9B,CCPO,MAAMQ,EAA0C,CAAC,KAAM,MAAO,OAAQ,QAAS,SAAU,WAEnFC,EAA8C,CAAC,MAE/CC,EAAwC,CAAC,MAAO,MAAO,OAEvDC,EAAyC,CAAC,KAE1CC,EAAwC,CAAC,OAGzCC,EAA0C,CAAC,KAAM,KAAM,MAKvDC,EAAmC,IAkBnCC,EAA0C,CACnD,CACIC,gBAAiBF,EACjBG,qBAtB2B,YAuB3BC,SAxBwD,OA0B5D,CACIF,gBArBsD,IAsBtDC,qBAvBkC,mBAwBlCC,SAzBsE,OA2B1E,CACIF,gBAtB0D,IAuB1DC,qBAxBoC,mBAyBpCC,SA1B0E,OA4B9E,CACIF,gBAvBgD,IAwBhDC,qBAzB+B,eA0B/BC,SA3BgE,OA6BpE,CACIF,gBAxBoD,IAyBpDC,qBA1BiC,eA2BjCC,SA5BoE,QAgC/DC,EAAoC,IAE1CX,KACAK,KACAF,KACAC,KACAH,GACLW,MAAK,CAACC,EAAqBC,IAClBA,EAAMC,OAASF,EAAME,SA4DnBC,EAAkD,CARL,CACtDC,SAAU,WACVC,MAAO,OACPC,QAAS,SACTT,SAAU,OArDmC,CAC7CO,SAAU,OACVC,MAAO,OACPC,QAAS,MACTT,SAAU,MAEwC,CAClDO,SAAU,OACVC,MAAO,MACPC,QAAS,MACTT,SAAU,MAQsC,CAChDO,SAAU,OACVC,MAAO,MACPC,QAAS,MACTT,SAAU,KAEsC,CAChDO,SAAU,OACVC,MAAO,OACPC,QAAS,MACTT,SAAU,KAhBqC,CAC/CO,SAAU,YACVC,MAAO,MACPC,QAAS,WACTT,SAAU,MAckC,CAC5CO,SAAU,SACVC,MAAO,MACPC,QAAS,QACTT,SAAU,KAEkC,CAC5CO,SAAU,SACVC,MAAO,OACPC,QAAS,QACTT,SAAU,KAEyC,CACnDO,SAAU,UACVC,MAAO,MACPC,QAAS,4BACTT,SAAU,MCpIR,SAAUU,EACZC,EACAC,EACAC,GAEA,MAAMC,EAAQF,EAAa1B,QAAQyB,GAEnC,IAAe,IAAXG,EAEA,OAAO,KAGX,MAAMC,EAAeD,EAAQD,EAEvBG,EAAcD,KAAgBH,EAAeA,EAAaG,GAAgB,KAEhF,OAAKC,EAIDA,EAAYC,cAAgBvC,EAGrBgC,EAAkBC,EAAUC,EAFVC,GAAaA,GAAa,EAAI,GAAK,IAKzDG,EATI,IAUf,CAEM,SAAUE,EAAcP,EAAwBC,EAAmCC,GACrF,MAAM,SAACb,GAAYW,EACbQ,EAAYT,EAAkBC,EAAUC,EAAcC,GAE5D,OAAQM,GAAaA,EAAUnB,WAAaA,CAChD,CCnCM,SAAUoB,EAAkBC,GAC9B,OAAOA,EAAK/C,SAAWI,CAC3B,CAEM,SAAU4C,EAAUD,GACtB,OAAOA,EAAK/C,OAAOG,QAAQ,QAAS,IACxC,CAEM,SAAU8C,EAAqBF,GACjC,MAAMG,EAA0BH,EAAKI,MAAM,KAEpCC,GAAeF,EAEtB,IAAKE,EACD,OAAO,EAGX,IAAK,MAAMC,KAAQH,EACf,GAAIG,IAASD,EACT,OAAO,EAIf,OAAO,CACX,CCmBA,MAAME,EAAc,8BACdC,EAAgB,oBC9ChB,SAAUC,EAAyBlF,GACrC,MAAwB,iBAAVA,GAAsBA,EAAM0B,OAAO+B,OAAS,CAC9D,CAEM,SAAU0B,EAAenF,GAC3B,OAAOA,EAAMoF,SAAS,IAC1B,CCJM,SAAUC,EAAiBC,EAA6BC,GAC1D,MAAOC,EAAQC,GAAQH,GAChBI,EAAQC,GAAQJ,EAEvB,QAASE,EAAOC,GAAUC,EAAOH,EACrC,CAEM,SAAUI,EACZC,EACAC,GAEA,IAAK,MAAMC,KAAeD,EACtB,GAAIT,EAAiBQ,EAAiBE,GAClC,OAAO,EAIf,OAAO,CACX,CAEA,SAASC,EAAkBC,EAAcC,GACrC,MAAMC,EAAyC,GAEzCC,EAAYH,EAAKzE,MAAM0E,GAE7B,IAAKE,EACD,MAAO,GAGX,IAAIC,EAAe,EAEnB,IAAK,MAAMC,KAAiBF,EAAW,CACnC,MAAMG,EAAQN,EAAK3D,QAAQgE,EAAeD,GACpCG,EAAMD,EAAQD,EAAc7C,OAAS,EAE3C4C,EAAeG,EAEfL,EAAWM,KAAK,CAACF,EAAOC,GAC5B,CAEA,OAAOL,CACX,CAEA,MAAMO,EAA0B,iDAE1B,SAAUC,EAAgBV,GAC5B,OAAOD,EAAkBC,EAAMS,EACnC,CAEA,MAAME,EAA2B,2EChD3BC,EAAuB,kCACvBC,EAAuB,kCAE7B,SAASC,EAAad,EAAce,EAA4BC,GAC5D,MAAMC,ED8CJ,SAA2BjB,GAC7B,OAAOD,EAAkBC,EAAMW,EACnC,CChD8BO,CAAiBlB,GACrCmB,EAAeT,EAAgBV,GAErC,OAAOA,EAAKpE,QAAQmF,GAAU,CAACxF,EAAe6F,EAAmBC,KAC7D,MAAMC,EAAyC,CAACD,EAAQA,GAExD,OAAI1B,EAAqB2B,EAAmBH,IAIxCxB,EAAqB2B,EAAmBL,GAHjC1F,EAOJ,YAAYyF,IAAazF,MAAUA,OAAW,GAE7D,CCkBA,SAASgG,EAAWvB,EAAcwB,GAC9B,MAAM,SAACrE,EAAQ,QAAES,EAAO,SAAEF,GAAY8D,EAChCC,EAAiBtE,EAASK,OAEhC,IAAKwC,EAAKb,SAAShC,GACf,OAAO6C,EAGX,MAAM0B,EAAmBhB,EAAgBV,GAEzC,IAAI2B,EA/CF,SAA+B3B,EAAcwB,GAC/C,MAAM,SAACrE,EAAQ,MAAEQ,GAAS6D,EAEpBtB,EAA4B,GAC5BuB,EAAiBtE,EAASK,OAEhC,GAAuB,IAAnBiE,EAEA,OAAOvB,EAGX,IAAI0B,EAA0B5B,EAAK3D,QAAQc,EAAU,GAErD,MAA4B,IAArByE,GAAwB,CAC3B,MAAMC,EAA0C7B,EAAKxE,MAAMoG,GAAiBrG,MAAMoC,GAElF,IAAKkE,EACD,MAAO,GAGX,MAAOC,GAAmBD,EACpBE,EAAwBD,EAAgBtE,OAE1CuE,IAA0BN,GAC1BvB,EAAWM,KAAKoB,GAGpBA,EAAkB5B,EAAK3D,QAAQc,EAAUyE,EAAkBG,EAC/D,CAEA,OAAI7B,EAAW1C,OAAS,GAAM,EACnB0C,EAAW1E,MAAM,GAAI,GAGzB0E,CACX,CAY2C8B,CAAqBhC,EAAMwB,GAGlEG,EAAoBA,EAAkBM,QAAQC,IAC1C,IAAK,MAAMC,KAAgBT,EAIvB,GAAItC,EAAiB+C,EAAc,CAHbD,EACFA,EAAgBT,EAAiB,IAGjD,OAAO,EAIf,OAAO,CAAI,IAGf,MAAMW,EAA0BT,EAAkBnE,OAElD,GAAgC,IAA5B4E,EACA,OAAOpC,EAGX,IAAIqC,EAA8BrC,EAAKxE,MAAM,EAAGmG,EAAkB,IAElE,IAAK,IAAIW,EAAsB,EAAGA,GAAuBF,EAAyBE,GAAuB,EAAG,CACxG,MAAMJ,EAAgBP,EAAkBW,GAClCC,EAAWvC,EAAKxE,MAAMmG,EAAkBW,EAAsB,GAAKb,EAAgBS,GAEzFG,GAAuBC,EAAsB,GAAM,EAAI1E,EAAU2E,EAAW7E,EAAW6E,CAC3F,CAEA,OAAOF,CACX,CC1EO,MAAMG,EAAkB,WAEzB,SAAUC,EAAajE,GACzB,OAAOA,EAAK5C,QAAQ4G,EAAiB,QACzC,CAMM,SAAUE,EAAmB3H,EAAqBR,GACpD,OAAOA,GAAgBiI,EAAgBxH,KAAKD,EAChD,CAGA,SAAS4H,EAActC,EAAuBuC,EAAcC,EAAaC,GACrE,MAAMC,EAAyB9D,EAAyB6D,GAAS,WAAWA,KAAW,GAGvF,MAAO,4BAA4BD,KAFd5D,EAAyB2D,GAAO,SAASA,KAAS,KAEdG,KAC7D,CAmBA,MAAMC,EAAwB,kDACxBC,EAAgC,kCAYhCC,EAAkC,WAClCC,EAAoC,WAcpCC,EAAuB,qEACvBC,GAAuB,iDACvBC,GAA+B,iCAGrC,SAASC,GAAalD,EAAuBmD,EAAkBC,EAAcX,EAAgBY,GACzF,MAAMC,EAAiB1E,EAAyB6D,GAAS,WAAWA,KAAW,GACzEc,EAAe3E,EAAyByE,GAAW,YAAYA,IAAY,GAC3EG,EAAOL,EAAShG,OAAS,EAAIgG,EAAWC,EAE9C,OAAIvE,EAAemB,GACR,YAAYxF,IAAa4I,IAAOG,KAAgBD,KAAkBE,QAItExD,CACX,CAGA,SAASS,GAAaT,EAAuBmD,EAAkBC,EAAcX,GAIzE,MAAO,YAAYW,KAHIxE,EAAyB6D,GAAS,WAAWA,KAAW,MAClEU,EAAShG,OAAS,EAAIgG,EAAWC,OAGlD,CAEA,SAASK,GAAgBL,GACrB,OAAOvE,EAAeuE,GAAQ5I,EAAa,EAC/C,CA8FM,SAAUkJ,GAAiB/D,EAAcgE,GAC3C,MAAM,OAACC,GAAUD,GACX,UAAC5J,GAAa6J,EAEpB,IAAIC,ET3HF,SAA4BA,EAAyBF,GACvD,OAAOE,EAAgBtI,QAAQM,GAA+BX,IAC1D,MAAMoD,EAA0BpD,EAAMqD,MAAM,KACrCuF,GAAexF,GAChB,aAACyF,GAAgBJ,EACjB9I,EAAKQ,EAAkBH,GAEvBF,EAAWJ,EAAgBC,EAAIkJ,GAErC,OAAK/I,EAIE,GAAG8I,cAAwBjJ,YAAakJ,EAAa/H,QAAQhB,GAAY,eAHrE,EAGmF,GAEtG,CS4G0BgJ,CAAkBrE,EAAMgE,GAiB9C,OAfAE,EAzJE,SAAoBlE,EAAcgE,GACpC,OAAOhE,EAEFpE,QAAQoH,EAAuBL,GAE/B/G,QAAQqH,GAA+B,CAAC5C,EAAuBuC,EAAc0B,IAxBtF,SACIjE,EACAuC,EACA0B,EACAN,GAEA,MAAMO,EAAetF,EAAyB2D,GAAO,SAASA,KAAS,IACjE,SAAC4B,GAAYR,EAEnB,OAAIM,KAAeE,EACR,4BAA4BA,EAASF,GAAavK,SAASwK,MAG/D,4BAA4BD,KAAeC,KACtD,CAWmBE,CAAsBpE,EAAeuC,EAAK0B,EAAaN,IAE1E,CAiJsBU,CAAUR,EAAiBF,GAE7CE,EAtEE,SAAmBlE,GACrB,OAAOA,EAAKpE,QAAQwH,EAAsBG,GAC9C,CAoEsBoB,CAAST,GACvB9J,IACA8J,EFnLF,SAA2BlE,GAC7B,OAAOc,EAAad,EAAMa,EAAsBhG,EACpD,CEiL0B+J,CAAiBV,IAGvCA,EAvEE,SAAmBlE,GACrB,OAAOA,EAAKpE,QAAQyH,GAAsBvC,GAC9C,CAqEsB+D,CAASX,GACvB9J,IACA8J,EF5LF,SAA2BlE,GAC7B,OAAOc,EAAad,EAAMY,EAAsB,GACpD,CE0L0BkE,CAAiBZ,IAGvCA,EAzFJ,SAAyBlE,EAAcgE,GACnC,OAAOhE,EAAKpE,QACR0H,IACA,CAACjD,EAAuBmD,EAAkBuB,IAvBlD,SACI1E,EACAmD,EACAuB,EACAf,GAEA,MAAM,SAACQ,GAAYR,EAEnB,GAAIe,KAAgBP,EAAU,CAC1B,MAAMf,EAAOe,EAASO,GAAchL,MAC9BiL,EAAexB,EAAShG,OAAS,EAAIgG,EAAWC,EAEtD,MAAO,YAAYK,GAAgBL,KAAQA,MAASuB,OACxD,CAEA,MAAMnB,EAAOL,EAAShG,OAAS,EAAIgG,EAAWuB,EAE9C,MAAO,YAAYjB,GAAgBiB,KAAgBA,MAAiBlB,OACxE,CAMmBoB,CAAqB5E,EAAemD,EAAUuB,EAAcf,IAG/E,CAkFsBkB,CAAgBhB,EAAiBF,GAEnDE,EA1JE,SAAuBlE,GACzB,OAAOA,EAEFpE,QAAQsH,EAAiC,kEAEzCtH,QAAQuH,EAAmC,+CACpD,CAoJsBgC,CAAajB,GDrI7B,SAAsBlE,GACxB,IAAIoF,EAASpF,EAEb,IAAK,MAAMwB,KAAmB/D,EAC1B2H,EAAS7D,EAAW6D,EAAQ5D,GAGhC,OAAO4D,CACX,CC8HWC,CAAYnB,EACvB,CC1NO,MAAMoB,GAAkD,CAC3DC,OAAQ,SACR,QAAW,OACXC,KAAM,OACNC,MAAO,SAGEC,GAAsD,CAC/DC,OAAQ,KACRC,OAAQ,MCAN,SAAUC,GAAkBrH,GAC9B,OAAOA,EAAK5C,QAAQ,YAAa,MAAQC,CAC7C,CAEM,SAAUiK,GAAYC,GACxB,MACMC,EAAiBD,EAAUtK,OAE3BwK,EAAgCD,EAAOpH,MAAM,KAC5CsH,GAAaD,EAEdE,EAAWH,EAAOA,EAAOxI,OAAS,GAExC,OAAI0I,IAAcC,GARA,MAQYD,EACnBZ,GAAiBC,OATV,MAYdY,EACOb,GAAiBG,MAGrBH,GAAiBE,IAC5B,CCJA,SAASY,GACLtI,EACAuI,EACAC,EACAC,EACAvC,GAEA,OAAOqC,EACFG,KAAKhI,GACK,OA9BnB,SACIV,EACAU,EACA8H,EACAC,EACAvC,GAEA,MAAM,SAAC7G,GAAYW,EAEnB,OAAOU,EACFI,MAAMzB,GACN8E,OAAO1D,GACPiI,KAAI,CAACC,EAAqBC,KACvB,MAAMC,EAAQL,EAAUI,IAAcpB,GAAiBsB,QAEvD,MAAO,IAAIL,YAAmBI,MDhBpC,SAAiCnI,EAAcwF,GACjD,OAAOD,GAAiBvF,EAAMwF,GAAcvI,MAChD,CCcoDoL,CAAuBJ,EAAazC,OAAkBuC,IAAW,IAE5GO,KAAKjL,EACd,CAY0BkL,CAAejJ,EAAUU,EAAM8H,EAAWC,EAAUvC,YAErE8C,KAAKjL,EACd,CCfM,SAAUmL,GAAgBjJ,EAAmCiG,GAC/D,OAAOjG,EACFyI,KAAI,CAAC1I,EAAwBmJ,IAShC,SACFnJ,EACAmJ,EACAlJ,EACAiG,GAEA,MAAM,SAAC7G,EAAQ,UAAE+J,EAAS,YAAEnM,EAAW,YAAEqD,EAAW,mBAAE+I,EAAkB,OAAElD,GAAUnG,GAC9E,cAAC7D,GAAiBgK,EAClBmD,EJuHJ,SAAmCtJ,GACrC,MAAM,mBAACqJ,EAAkB,OAAElD,GAAUnG,GAC/B,YAAC/C,GAAe+C,GAChB,aAACvD,GAAgB0J,EAEvB,GAAkC,IAA9BkD,EAAmB3J,OACnB,OAAO3B,EAGX,MACMwL,EADwB3E,EAAmB3H,EAAaR,GACvBwB,EAAeD,EAChDwL,EAA2BH,EAAmB3J,OAC9C+J,EAA0BD,EAA2B,EACrDE,EAA4BC,MAAMC,KAAa,CAAClK,OAAQ8J,IAA2BK,KAAK,IAE9F,IAAK,IAAIC,EAAY,EAAGA,EAAYN,EAA0BM,GAAa,EAAG,CAC1E,MAAMC,EAAiBV,EAAmBS,GAG1C,GAFqBlF,EAAmBmF,EAAgBtN,GAEtC,CACd,MAAMuN,EAAiCD,EAAejM,QAAQ4G,EAAiB3G,GAE/E2L,EAAWI,GACPA,IAAcL,EACRO,EACAA,EAAiC/L,CAC/C,MACIyL,EAAWI,GAAaA,IAAcL,EAA0BM,EAAiBA,EAAiB/L,CAE1G,CAEA,OAAOuL,EAASG,EAAWV,KAAKjL,EACpC,CIvJmCkM,CAAyBjK,GAClDkK,EAAkBhB,GAAgBE,EAAWlD,GAEnD,IAAIE,EAAqCnJ,EJhC7Ba,QAAQ4G,EAAiB3G,GIgCmBuL,EAMxD,GAJAlD,EAAkBH,GAAiBG,EAAiBF,GAEpDE,GAAmB8D,EAEflN,EAAyBC,GACzB,MAAO,GAGX,GT7BE,SAAoB+C,GACtB,OAAOnB,EAAiBwC,SAASrB,EAASX,SAC9C,CS2BQ8K,CAAUnK,GACV,MAAO,QAGX,GT7BE,SAAqBA,GACvB,OAAOlB,EAAkBuC,SAASrB,EAASX,SAC/C,CS2BQ+K,CAAWpK,GACX,ODpBF,SAAsBA,EAAwBkG,GAChD,MAAM,SAAC7G,EAAQ,mBAAEgK,EAAkB,KAAE3I,GAAQV,EAEvCuI,EAAW,CAAC7H,KAAS2I,GAErBgB,EAAc9B,EAASjL,KAAKyK,IAGlC,QAAoBuC,IAAhBD,EAGA,MAAO,iBAFiB/B,GAAmBtI,EAAUuI,EAAU,GAAIX,GAAmBC,OAAQ3B,qBAKlG,MAAMqE,EAAmBhC,EAAShK,QAAQ8L,GACpCG,EAAejC,EAAS7K,MAAM,EAAG6M,GACjCE,EAAelC,EAAS7K,MAAM6M,EAAmB,GACjD/B,EDzBJ,SAAuBnJ,EAAwBqL,GACjD,OAAOA,EAAW5J,MAAMzB,GAAU8E,OAAO1D,GAAmBiI,IAAmBV,GACnF,CCuBsB2C,CAAatL,EAAUgL,GAKzC,MAAO,iBAHa/B,GAAmBtI,EAAUwK,EAAchC,EAAWZ,GAAmBE,OAAQ5B,oBACjFoC,GAAmBtI,EAAUyK,EAAcjC,EAAWZ,GAAmBC,OAAQ3B,oBAGzG,CCHe0E,CAAY5K,EAAUkG,GAGjC,GT7BE,SAAoBlG,GACtB,OAAOjB,EAAiBsC,SAASrB,EAASX,SAC9C,CS2BQwL,CAAU7K,GAAW,CACrB,MAAM8K,EAAW3O,EAAcc,EAAaoM,EAAmBL,KAAK,OAEpE,OAAO/L,EAAc,oBAAoBA,MAAgB6N,WAAoB,SAASA,UAC1F,CAEA,GAAI7N,IAAgBc,GAAoC,IAArBqL,EAAU1J,OACzC,OAAO3B,EAGX,GTjEE,SAAsBiC,GACxB,OAAOrB,EAAmB0C,SAASrB,EAASX,SAChD,CS+DQ0L,CAAY/K,GAAW,CACvB,MAAMgL,EAAY3L,EAASK,OAAS,EAEpC,MAAO,KAAKsL,KAAa5E,OAAqB4E,IAClD,CAEA,GTzCE,SAA0BhL,GAC5B,OAAOpB,EAAuByC,SAASrB,EAASX,SACpD,CSuCQ4L,CAAgBjL,GAChB,MAAO,eAAeoG,iBAG1B,GTvEE,SAAsBpG,GACxB,OAAOhB,EAAmBqC,SAASrB,EAASX,SAChD,CSqEQ6L,CAAYlL,GAMZ,MAAO,GALaO,EAAcP,EAAUC,GAAe,GAE9B,OAAS,SAGfmG,SAJJ7F,EAAcP,EAAUC,EAAc,GAE5B,QAAU,KAK3C,GT5EE,SAAsBD,GACxB,IAAK,MAAMmL,KAAejM,EACtB,GAAIiM,EAAY9L,WAAaW,EAASX,SAClC,OAAO,EAIf,OAAO,CACX,CSoEQ+L,CAAYpL,GAAW,CACvB,MAAMqL,EAAc9K,EAAcP,EAAUC,GAAe,GACrDqL,EAAa/K,EAAcP,EAAUC,EAAc,IAClDZ,SAAUkM,GAAoBvL,EAC/BuJ,EAAS8B,EACT,aJ4CR,SAA8BG,GAChC,IAAK,MAAML,KAAejM,EAAiB,CACvC,MAAM,SAACG,EAAQ,gBAAEF,GAAmBgM,EAEpC,GAAIK,IAAqBnM,EACrB,OAAOF,CAEf,CAIA,OAAOF,CACX,CIxD2BwM,CAAoBF,cJ0DzC,SAAqBjL,GACvB,MAAMoL,EAAWpL,EAAY/B,QAAQ,KAErC,OAAO+B,EAAY5C,MAAM,EAAGgO,EAChC,CI9D4EC,CAAWrL,OACzE,GAGN,MAAO,GAAGiJ,QAAanD,SAFPkF,EAAa,QAAU,IAG3C,CAEA,OAAIrO,IAAgBc,GT3DlB,SAA6BiC,GAC/B,MAAM,YAACM,GAAeN,EAEtB,OAA2C,IAApCM,EAAYsL,OAAO3K,IAA4D,IAAtCX,EAAYsL,OAAO1K,EACvE,CSuDuC2K,CAAmB7L,IJnCpD,SAA0B/C,GAC5B,OAAOA,EAAYa,QAAQoH,EAAuB,IAAIvH,SAAWI,CACrE,CIiCuE+N,CAAgB7O,GACxEmJ,EAGJ,MAAMA,OACjB,CAlFmB2F,CAAe/L,EAAUmJ,EAAelJ,EAAciG,KAEhEwC,IAAI/D,GACJqE,KAAKjL,EACd,CCzBM,SAAUiO,GAASC,EAAiB9F,EAAoCjK,GAC1E,MAAMgQ,EAAqC,IACpChQ,KACAiK,IAGD,WAACzJ,GAAcwP,EAEfC,EAA6C,IAC5CjQ,KACAiK,EACHzJ,YAAY,GAGV0P,EAA2B,CAC7B/C,mBAAoB,GACpBD,UAAW,GACXjD,OAAQ+F,EACRxL,KAAM3C,EACNd,YAAa,GACb6M,WAAY,EACZzK,SAAUtB,EACVsO,YAAa,EACb/L,YAAa,IAEXgM,EAA8C,CAACF,GAC/CG,EAAyC,CAACH,GAC1ClG,EAAiC,CACnCsG,aAAc,KACdrG,OAAQ+F,EACR5F,aAAc,GACdmG,cAAe,KACf/F,SAAU,CAAC,GAGfuF,EAAQnL,MAAM,MAAM4L,SAAQ,CAAChM,EAAcoJ,EAAmB6C,MCE5D,SACFjM,EACAoJ,EACA6C,EACAL,EACAC,EACArG,GAEA,MAAM5F,EAAcI,EAAK/C,OACnBiP,EAAgBtM,IAAgBvC,EAChC8O,EAAgBD,EAChBL,EAAkBA,EAAkB7M,OAAS,GAAG2M,WAChD3L,EAAKkL,OAAO,OACZS,EAAaS,KAAKC,IAAI,EAAGF,GACzBG,EAAyC,CAC3C/P,YAAac,EACbsB,SAAUtB,IAGR,SAACsB,EAAQ,YAAEpC,GAAe2P,EAAgBI,EAxDpD,SAAsB1M,GAClB,IAAK,MAAMjB,KAAYC,EACnB,GAAIgB,EAAY2M,WAAW5N,GACvB,MAAO,CACHpC,YAAa0D,EAAUL,EAAYxC,QAAQuB,EAAUtB,IACrDsB,YAKZ,IAAK,MAAM6N,KAAgBrO,EACvB,GAAIyB,EAAY2M,WAAWC,IAAiBtM,EAAqBN,GAC7D,MAAO,CACHrD,YAAac,EACbsB,SAAU6N,GAKtB,IAAK,MAAM/B,KAAejM,EAAiB,CACvC,MAAM,SAACG,EAAQ,qBAAED,GAAwB+L,EAEzC,GAAiD,IAA7C7K,EAAYsL,OAAOxM,GACnB,MAAO,CACHnC,YAAa0D,EAAUL,EAAYxC,QAAQsB,EAAsBrB,IACjEsB,WAGZ,CAEA,MAAO,CACHpC,YAAa0D,EAAUL,GACvBjB,SAAUtB,EAElB,CAsB0EoP,CAAa7M,GAE7EN,EAAyB,CAC3BqJ,mBAAoB,GACpBD,UAAW,GACXjD,OAAQD,EAAaC,OACrBzF,KAAMkM,EAAgB7O,EAAc2C,EACpCzD,cACA6M,YACAzK,WACAgN,aACA/L,eAGJ,GAAIvB,EAAiBsC,SAAShC,GAAW,CACrC,GAAI6G,EAAasG,cAAgBvP,IAAgBc,EAE7C,OADAmI,EAAasG,aAAe,MACrB,EAGXtG,EAAasG,aAAexM,CAChC,CAEA,MAAM,aAACwM,GAAgBtG,EAEvB,GAAIsG,GAAgBA,IAAiBxM,EAEjC,OADAwM,EAAanD,mBAAmB3G,KAAK1C,EAASU,OACvC,EAGX,MAAM0M,EftEJ,SAA0BnQ,GAC5B,MAAMoQ,EAAcpQ,EAAYQ,MAAMW,GAEtC,OAAKiP,EAIEA,EAAY3E,IAAIrK,GAHZ,EAIf,Ce8DgCiP,CAAgBrQ,IACtC,aAACqJ,EAAY,cAAEmG,EAAa,SAAE/F,GAAYR,EAIhD,GfjEE,SAA6BqH,EAA+BC,GAC9D,IAAK,MAAMC,KAAYF,EAAU,CAC7B,MAAM,GAACnQ,EAAE,oBAAEoB,GAAuBiP,EAC5BC,EAAoBF,EAAOlQ,MAAMqQ,GAC5BA,EAAOvQ,KAAOA,IAGrBsQ,EACKA,EAAkBlP,sBACnBkP,EAAkBlP,oBAAsBA,GAG5CgP,EAAO9K,KAAK+K,EAEpB,CACJ,CegDIG,CAAmBR,EAAqB9G,GAEpCxH,EAAkBuC,SAAShC,GAAW,CACtC,GAAIoN,EAIA,OADAA,EAAcpD,mBAAmB3G,KAAK1C,EAASU,OACxC,EAIXwF,EAAauG,cAAgBzM,CACjC,MAGIkG,EAAauG,cAAgB,KAGjC,MAAMoB,EClHJ,SAA0B5Q,GAC5B,MAAM6Q,EAAY,6BAA6BC,KAAK9Q,GAEpD,OAAK6Q,EASE,CACH1S,IALQ0S,EAAU,GAMlB7R,MAJUgB,EAAYS,MAAMT,EAAYsB,QAAQ,MAAQ,GAAGZ,QANpD,IAYf,CDkGyBqQ,CAAgB/Q,GAErC,GAAI+C,EAASX,WAAatB,GAAed,EAAYyC,OAAS,EAAG,CAC7D,MAAMuO,EAAgB1B,EAAkB7M,OAAS,EAC3CwO,EAAW3B,EAAkB4B,GAAGF,GAChCG,EAAUC,QAAQH,GAAYpP,EAAkBuC,SAAS6M,EAAS7O,WAMxE,GAJIwO,IACAnH,EAASmH,EAAazS,KAAOyS,GAG7BK,GAAYA,EAASjR,YAAYyC,OAAS,IAAM0O,IAAYP,EAE5D,OADAK,EAAS7E,mBAAmB3G,KAAKzF,IAC1B,CAEf,CAEA,MAAMqR,Eb9FJ,SAAoBtO,EAAwBC,GAG9C,IAAK,IAAIkJ,EAFkBlJ,EAAaP,OAEM,EAAGyJ,GAAiB,EAAGA,GAAiB,EAAG,CACrF,MAAMoF,EAAoBtO,EAAakJ,GAEvC,GAAIoF,EAAkBlC,WAAarM,EAASqM,WACxC,OAAOkC,CAEf,CAIA,OAAO,IACX,CagF2BC,CAAUxO,EAAUuM,GAEtC+B,IAKDT,IAIJS,EAAelF,UAAU1G,KAAK1C,GAC9BuM,EAAkB7J,KAAK1C,GAEnBhD,EAAyBC,If/F3B,SAAsB+C,EAAwBwN,GAChD,MAAM,YAACvQ,GAAe+C,EAChByO,EAAa,kBAAkBV,KAAK9Q,GAE1C,IAAKwR,EACD,OAGJ,MAAOC,GAASD,EAEVrR,EAAKsR,EAAMhR,MAAM,GAAI,GAAGC,OAExBJ,EAAWJ,EAAgBC,EAAIoQ,GAEjCjQ,EACAA,EAASiB,oBAAsBwB,EAInCwN,EAAO9K,KAAK,CACRlE,oBAAqBwB,EACrB5C,KACAkB,kBAAmBrB,EACnBwB,KAAMP,EAAgBQ,OAE9B,CeuEQiQ,CAAY3O,EAAUsG,IAI9B,CD3GQsI,CAAUlO,EAAMoJ,EAAW6C,EAAaL,EAAwBC,EAAmBrG,EAAa,IAGpG,MAAM2I,EAAc3F,GAAgBoD,EAAwBpG,GAEtD4I,EAAyC5I,EAAaI,aAAaoC,KAAKnL,IAC1E,MAAM,GAACH,GAAMG,EACPwR,EjB9BR,SAA+BxR,GACjC,MAAM,kBAACe,EAAiB,oBAAEE,GAAuBjB,EAEjD,GAAIiB,EAAqB,CACrB,MAAM,YAACvB,EAAW,mBAAEoM,GAAsB7K,EACpCgE,EAAQvF,EAAYsB,QAAQ,MAAQ,EAE1C,MAAO,GAAGtB,EAAYS,MAAM8E,OAAW6G,EAAmBL,KAAK,OACnE,CAEA,OAAO1K,CACX,CiBmBkC0Q,CAAqBzR,GAE/C,MAAO,WAAWH,MAAO4O,GAAS+C,EAAmB5C,SAA8B,IAQjF8C,EAAc,CAACJ,EAJkB,IAAnCC,EAAwBpP,OAClB,GACA,CAAC,QAAS,mBAAoBoP,EAAyB,SAAS9F,KAAK,KAEpBA,KAAK,IAEhE,IAAKtM,EACD,OAAOuS,EAGX,MAAMC,EGjEJ,SAAkChD,GACpC,MAAOvP,iBAAkBwS,EAAsB,UAAE5S,GAAa2P,GACvDvP,iBAAkByS,GAA2BlT,EASpD,MAAO,GANHiT,IAA2BC,EACrBA,EACA,GAAGA,KAA2BD,OAETvS,EAAkBL,IAGrD,CHqDyC8S,CAAwBnD,GAE7D,MAAO,eAAegD,MAAyBD,SACnD,CIhEO,MAAMK,GAA0B,oBAC1BC,GAA2B,qBAC3BC,GAAyBtT,EAAsBS,iB","sources":["webpack://markdown-pro/webpack/bootstrap","webpack://markdown-pro/./www/library/src/markdown-const.ts","webpack://markdown-pro/webpack/runtime/define property getters","webpack://markdown-pro/webpack/runtime/hasOwnProperty shorthand","webpack://markdown-pro/webpack/runtime/make namespace object","webpack://markdown-pro/./www/library/src/parser/footnote/footnote-helper.ts","webpack://markdown-pro/./www/library/src/render/render-const.ts","webpack://markdown-pro/./www/library/src/parser/footnote/footnote-const.ts","webpack://markdown-pro/./www/library/src/parser/footnote/footnote.ts","webpack://markdown-pro/./www/library/src/parser/parser-selector.ts","webpack://markdown-pro/./www/library/src/parser/util/navigation.ts","webpack://markdown-pro/./www/library/src/parser/util/string.ts","webpack://markdown-pro/./www/library/src/parser/util/is-tag.ts","webpack://markdown-pro/./www/library/src/parser/util/is.ts","webpack://markdown-pro/./www/library/src/render/render-util.ts","webpack://markdown-pro/./www/library/src/render/render-link.ts","webpack://markdown-pro/./www/library/src/render/render-pair-tag.ts","webpack://markdown-pro/./www/library/src/render/render-helper.ts","webpack://markdown-pro/./www/library/src/render/render-table/render-table-const.ts","webpack://markdown-pro/./www/library/src/render/render-table/render-table-helper.ts","webpack://markdown-pro/./www/library/src/render/render-table/render-table.ts","webpack://markdown-pro/./www/library/src/render/render.ts","webpack://markdown-pro/./www/library/src/markdown.ts","webpack://markdown-pro/./www/library/src/parser/parse-line.ts","webpack://markdown-pro/./www/library/src/parser/util/variable.ts","webpack://markdown-pro/./www/library/src/helper.ts","webpack://markdown-pro/./www/library/library.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import type {MarkdownConfigType} from \"../library\";\n\nexport enum ThemeNameEnum {\n    auto = \"auto\",\n    dark = \"dark\",\n    light = \"light\",\n}\n\nexport const defaultMarkdownConfig: MarkdownConfigType = {\n    codeHighlight: (langName: string, code: string): string => {\n        return code;\n    },\n    parseLink: true,\n    themeName: ThemeNameEnum.auto,\n    useLineBreak: false,\n    useWrapper: true,\n    wrapperClassName: \"md-pro\",\n};\n\nexport const themeClassNameMap: Record<ThemeNameEnum, string> = {\n    [ThemeNameEnum.auto]: `${defaultMarkdownConfig.wrapperClassName}-theme-${ThemeNameEnum.auto}`,\n    [ThemeNameEnum.dark]: `${defaultMarkdownConfig.wrapperClassName}-theme-${ThemeNameEnum.dark}`,\n    [ThemeNameEnum.light]: `${defaultMarkdownConfig.wrapperClassName}-theme-${ThemeNameEnum.light}`,\n};\n\nexport const mailPrefix = \"mailto:\";\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type {FootnoteType} from \"../parser-type\";\n\nexport function getIsFootnoteDescription(lineContent: string): boolean {\n    return /^\\[\\^[^\\]]+\\]:/u.test(lineContent);\n}\n\nexport function getFootnoteById(id: string, list: Array<FootnoteType>): FootnoteType | undefined {\n    return list.find((footnote: FootnoteType): boolean => {\n        return footnote.id === id;\n    });\n}\n\nexport function getFootnoteInlineLineContent(match: string): string {\n    return match.slice(3, -1).trim();\n}\n\n// See findFootnoteMarkGlobalRegExp\nexport function getFootnoteMarkId(match: string): string {\n    // eslint-disable-next-line newline-per-chained-call\n    return getFootnoteInlineLineContent(match).toLowerCase().replace(/\\W/gu, \" \").trim().replace(/\\s+/gu, \"-\");\n}\n\nexport function getMdFootnoteContent(footnote: FootnoteType): string {\n    const {inlineLineContent, descriptionLineData} = footnote;\n\n    if (descriptionLineData) {\n        const {lineContent, additionalLineList} = descriptionLineData;\n        const start = lineContent.indexOf(\"]:\") + 2;\n\n        return `${lineContent.slice(start)}\\n${additionalLineList.join(\"\\n\")}`;\n    }\n\n    return inlineLineContent;\n}\n","export const emptyString = \"\";\nexport const space = \" \";\nexport const breakLineTag = \"<br/>\";\n","import type {FootnoteTypeType} from \"../parser-type\";\n\nexport const footnoteTypeMap: {[key in FootnoteTypeType]: FootnoteTypeType} = {\n    inline: \"inline\",\n    \"super\": \"super\",\n};\n\n// Export const footnotePrefix = 'fn-';\n\nexport const findFootnoteMarkGlobalRegExp = /\\S\\[\\^[^\\]]+?\\]|\\S\\^\\[[^\\]]+?\\]/gu;\n","import type {DocumentMetaType, FootnoteType,LineDataType} from \"../parser-type\";\nimport {findFootnoteMarkGlobalRegExp, footnoteTypeMap} from \"./footnote-const\";\nimport {getFootnoteById, getFootnoteInlineLineContent, getFootnoteMarkId} from \"./footnote-helper\";\n\nfunction matchToFootnote(match: string): FootnoteType {\n    const id = getFootnoteMarkId(match);\n    const inlineLineContent = getFootnoteInlineLineContent(match);\n\n    if (match.indexOf(\"[^\") === 1) {\n        return {\n            descriptionLineData: null,\n            id,\n            inlineLineContent,\n            type: footnoteTypeMap.super,\n        };\n    }\n\n    return {\n        descriptionLineData: null,\n        id,\n        inlineLineContent,\n        type: footnoteTypeMap.inline,\n    };\n}\n\nexport function getFootnoteList(lineContent: string): Array<FootnoteType> {\n    const matchedList = lineContent.match(findFootnoteMarkGlobalRegExp);\n\n    if (!matchedList) {\n        return [];\n    }\n\n    return matchedList.map(matchToFootnote);\n}\n\nexport function fromToFootnoteList(fromList: Array<FootnoteType>, toList: Array<FootnoteType>): void {\n    for (const fromItem of fromList) {\n        const {id, descriptionLineData} = fromItem;\n        const candidateToExtend = toList.find((toItem: FootnoteType): boolean => {\n            return toItem.id === id;\n        });\n\n        if (candidateToExtend) {\n            if (!candidateToExtend.descriptionLineData) {\n                candidateToExtend.descriptionLineData = descriptionLineData;\n            }\n        } else {\n            toList.push(fromItem);\n        }\n    }\n}\n\nexport function addLineData(lineData: LineDataType, toList: Array<FootnoteType>): void {\n    const {lineContent} = lineData;\n    const rawMatchId = /\\[\\^[^\\]]+?\\]:/u.exec(lineContent);\n\n    if (!rawMatchId) {\n        return;\n    }\n\n    const [rawId] = rawMatchId;\n\n    const id = rawId.slice(2, -2).trim();\n\n    const footnote = getFootnoteById(id, toList);\n\n    if (footnote) {\n        footnote.descriptionLineData = lineData;\n        return;\n    }\n\n    toList.push({\n        descriptionLineData: lineData,\n        id,\n        inlineLineContent: lineContent,\n        type: footnoteTypeMap.super,\n    });\n}\n\nexport function makeFootnoteSuper(fullLineContent: string, documentMeta: DocumentMetaType): string {\n    return fullLineContent.replace(findFootnoteMarkGlobalRegExp, (match: string): string => {\n        const charList: Array<string> = match.split(\"\");\n        const [firstLetter] = charList;\n        const {footnoteList} = documentMeta;\n        const id = getFootnoteMarkId(match);\n\n        const footnote = getFootnoteById(id, footnoteList);\n\n        if (!footnote) {\n            return \"\";\n        }\n\n        return `${firstLetter}<a href=\"#${id}\"><sup>[${footnoteList.indexOf(footnote) + 1}]</sup></a>`;\n    });\n}\n","import type {\n    OlParseDataType,\n    OlTypeBigAlphabetType,\n    OlTypeBigRomanNumberType,\n    OlTypeNumericType,\n    OlTypeSmallAlphabetType,\n    OlTypeSmallRomanNumberType,\n    PairTagSelectorType,\n    SelectorOlBigAlphabetItemType,\n    SelectorOlBigRomanNumberItemType,\n    SelectorOlNumericItemType,\n    SelectorOlSmallAlphabetItemType,\n    SelectorOlSmallRomanNumberItemType,\n    SelectorType,\n} from \"./parser-type\";\n\nexport const selectorHeaderList: Array<SelectorType> = [\"# \", \"## \", \"### \", \"#### \", \"##### \", \"###### \"];\n// Export const selectorHeaderList: Array<SelectorHeaderType> = ['# ', '## ', '### ', '#### ', '##### ', '###### '];\nexport const selectorBlockquoteList: Array<SelectorType> = [\"> \"];\n// Export const selectorBlockquoteList: Array<SelectorBlockquoteType> = ['> '];\nexport const selectorLineList: Array<SelectorType> = [\"---\", \"***\", \"___\"];\n// Export const selectorLineList: Array<SelectorLineType> = ['---', '***', '___'];\nexport const selectorTableList: Array<SelectorType> = [\"|\"];\n// Export const selectorTableList: Array<SelectorTableType> = ['|'];\nexport const selectorCodeList: Array<SelectorType> = [\"```\"];\n// Export const selectorCodeList: Array<SelectorCodeType> = ['```'];\n\nexport const selectorULItemList: Array<SelectorType> = [\"+ \", \"- \", \"* \"];\n// Export const selectorULItemList: Array<SelectorUlItemType> = ['+ ', '- ', '* '];\n\nexport const olNumericItemSelector: SelectorOlNumericItemType = \"0. \";\nexport const olNumericItemRegExp = /^\\d+\\.\\s/u;\nexport const olNumericType: OlTypeNumericType = \"1\";\n\nexport const olBigRomanNumberItemSelector: SelectorOlBigRomanNumberItemType = \"I. \";\nexport const olBigRomanNumberItemRegExp = /^[CDILMVX]+\\.\\s/u;\nexport const olBigRomanNumberType: OlTypeBigRomanNumberType = \"I\";\n\nexport const olSmallRomanNumberItemSelector: SelectorOlSmallRomanNumberItemType = \"i. \";\nexport const olSmallRomanNumberItemRegExp = /^[cdilmvx]+\\.\\s/u;\nexport const olSmallRomanNumberType: OlTypeSmallRomanNumberType = \"i\";\n\nexport const olBigAlphabetItemSelector: SelectorOlBigAlphabetItemType = \"A. \";\nexport const olBigAlphabetItemRegExp = /^[A-Z]+\\.\\s/u;\nexport const olBigAlphabetType: OlTypeBigAlphabetType = \"A\";\n\nexport const olSmallAlphabetItemSelector: SelectorOlSmallAlphabetItemType = \"a. \";\nexport const olSmallAlphabetItemRegExp = /^[a-z]+\\.\\s/u;\nexport const olSmallAlphabetType: OlTypeSmallAlphabetType = \"a\";\n\nexport const oLParseDataList: Array<OlParseDataType> = [\n    {\n        olAttributeType: olNumericType,\n        regExpSearchSelector: olNumericItemRegExp,\n        selector: olNumericItemSelector,\n    },\n    {\n        olAttributeType: olBigRomanNumberType,\n        regExpSearchSelector: olBigRomanNumberItemRegExp,\n        selector: olBigRomanNumberItemSelector,\n    },\n    {\n        olAttributeType: olSmallRomanNumberType,\n        regExpSearchSelector: olSmallRomanNumberItemRegExp,\n        selector: olSmallRomanNumberItemSelector,\n    },\n    {\n        olAttributeType: olBigAlphabetType,\n        regExpSearchSelector: olBigAlphabetItemRegExp,\n        selector: olBigAlphabetItemSelector,\n    },\n    {\n        olAttributeType: olSmallAlphabetType,\n        regExpSearchSelector: olSmallAlphabetItemRegExp,\n        selector: olSmallAlphabetItemSelector,\n    },\n];\n\nexport const selectorList: Array<SelectorType> = [\n    // ...selectorLineList,\n    ...selectorHeaderList,\n    ...selectorULItemList,\n    ...selectorTableList,\n    ...selectorCodeList,\n    ...selectorBlockquoteList,\n].sort((itemA: SelectorType, itemB: SelectorType): number => {\n    return itemB.length - itemA.length;\n});\n\nconst pairTagSelectorBold: PairTagSelectorType = {\n    closeTag: \"</b>\",\n    equal: /\\*+/u,\n    openTag: \"<b>\",\n    selector: \"**\",\n};\nconst pairTagSelectorUnderline: PairTagSelectorType = {\n    closeTag: \"</u>\",\n    equal: /_+/u,\n    openTag: \"<u>\",\n    selector: \"__\",\n};\nconst pairTagSelectorStrike: PairTagSelectorType = {\n    closeTag: \"</strike>\",\n    equal: /~+/u,\n    openTag: \"<strike>\",\n    selector: \"~~\",\n};\nconst pairTagSelectorItalic1: PairTagSelectorType = {\n    closeTag: \"</i>\",\n    equal: /_+/u,\n    openTag: \"<i>\",\n    selector: \"_\",\n};\nconst pairTagSelectorItalic2: PairTagSelectorType = {\n    closeTag: \"</i>\",\n    equal: /\\*+/u,\n    openTag: \"<i>\",\n    selector: \"*\",\n};\nconst pairTagSelectorSub: PairTagSelectorType = {\n    closeTag: \"</sub>\",\n    equal: /~+/u,\n    openTag: \"<sub>\",\n    selector: \"~\",\n};\nconst pairTagSelectorSup: PairTagSelectorType = {\n    closeTag: \"</sup>\",\n    equal: /\\^+/u,\n    openTag: \"<sup>\",\n    selector: \"^\",\n};\nconst pairTagSelectorInlineCode: PairTagSelectorType = {\n    closeTag: \"</code>\",\n    equal: /`+/u,\n    openTag: '<code data-type=\"inline\">',\n    selector: \"`\",\n};\n\nconst pairTagSelectorBoldAndItalic: PairTagSelectorType = {\n    closeTag: \"</i></b>\",\n    equal: /\\*+/u,\n    openTag: \"<b><i>\",\n    selector: \"***\",\n};\n\n// More long selectors should be first\nexport const pairTagSelectorList: Array<PairTagSelectorType> = [\n    pairTagSelectorBoldAndItalic,\n    pairTagSelectorBold,\n    pairTagSelectorUnderline,\n    pairTagSelectorItalic1,\n    pairTagSelectorItalic2,\n    pairTagSelectorStrike,\n    pairTagSelectorSub,\n    pairTagSelectorSup,\n    pairTagSelectorInlineCode,\n];\n","import {emptyString} from \"../../render/render-const\";\nimport type {LineDataType} from \"../parser-type\";\n\nexport function searchSiblingItem(\n    lineData: LineDataType,\n    lineDataList: Array<LineDataType>,\n    direction: number\n): LineDataType | null {\n    const index = lineDataList.indexOf(lineData);\n\n    if (index === -1) {\n        // Console.error('lineDataList should contain lineData');\n        return null;\n    }\n\n    const siblingIndex = index + direction;\n\n    const siblingItem = siblingIndex in lineDataList ? lineDataList[siblingIndex] : null;\n\n    if (!siblingItem) {\n        return null;\n    }\n\n    if (siblingItem.trimmedLine === emptyString) {\n        const updatedDirection = direction + (direction >= 0 ? 1 : -1);\n\n        return searchSiblingItem(lineData, lineDataList, updatedDirection);\n    }\n\n    return siblingItem;\n}\n\nexport function getIsEdgeLine(lineData: LineDataType, lineDataList: Array<LineDataType>, direction: number): boolean {\n    const {selector} = lineData;\n    const foundItem = searchSiblingItem(lineData, lineDataList, direction);\n\n    return !foundItem || foundItem.selector !== selector;\n}\n\nexport function getParent(lineData: LineDataType, lineDataList: Array<LineDataType>): LineDataType | null {\n    const linaDataListLength = lineDataList.length;\n\n    for (let lineDataIndex = linaDataListLength - 1; lineDataIndex >= 0; lineDataIndex -= 1) {\n        const lineDataCandidate = lineDataList[lineDataIndex];\n\n        if (lineDataCandidate.spaceCount < lineData.spaceCount) {\n            return lineDataCandidate;\n        }\n    }\n\n    // Console.error('Parent not found');\n\n    return null;\n}\n","import {emptyString} from \"../../render/render-const\";\n\nexport function filterEmptyString(line: string): boolean {\n    return line.trim() !== emptyString;\n}\n\nexport function cleanLine(line: string): string {\n    return line.trim().replace(/\\s+/gu, \" \");\n}\n\nexport function getIsAllSymbolsEqual(line: string): boolean {\n    const charList: Array<string> = line.split(\"\");\n\n    const [firstSymbol] = charList;\n\n    if (!firstSymbol) {\n        return true;\n    }\n\n    for (const char of charList) {\n        if (char !== firstSymbol) {\n            return false;\n        }\n    }\n\n    return true;\n}\n","import {\n    oLParseDataList,\n    selectorBlockquoteList,\n    selectorCodeList,\n    selectorHeaderList,\n    selectorLineList,\n    selectorTableList,\n    selectorULItemList,\n} from \"../parser-selector\";\nimport type {LineDataType} from \"../parser-type\";\n\nexport function getIsHeader(lineData: LineDataType): boolean {\n    return selectorHeaderList.includes(lineData.selector);\n}\n\nexport function getIsUlItem(lineData: LineDataType): boolean {\n    return selectorULItemList.includes(lineData.selector);\n}\n\nexport function getIsOlItem(lineData: LineDataType): boolean {\n    for (const oLParseData of oLParseDataList) {\n        if (oLParseData.selector === lineData.selector) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function getIsLine(lineData: LineDataType): boolean {\n    return selectorLineList.includes(lineData.selector);\n}\n\nexport function getIsTable(lineData: LineDataType): boolean {\n    return selectorTableList.includes(lineData.selector);\n}\n\nexport function getIsCode(lineData: LineDataType): boolean {\n    return selectorCodeList.includes(lineData.selector);\n}\n\nexport function getIsBlockquote(lineData: LineDataType): boolean {\n    return selectorBlockquoteList.includes(lineData.selector);\n}\n\nconst htmlPairTag = /<(\\w+)[^>]*>[\\S\\s]*?<\\/\\1>/u;\nconst htmlSingleTag = /<\\w+[^>]*?\\s*\\/>/u;\n\nexport function getIsStartWithHtml(lineData: LineDataType): boolean {\n    const {trimmedLine} = lineData;\n\n    return trimmedLine.search(htmlPairTag) === 0 || trimmedLine.search(htmlSingleTag) === 0;\n}\n","export function hasStringNonEmptySymbols(value: unknown): value is string {\n    return typeof value === \"string\" && value.trim().length > 0;\n}\n\nexport function hasEmailSymbol(value: string): boolean {\n    return value.includes(\"@\");\n}\n","export type PairNumberArrayType = [number, number];\n\nexport function harArrayOverflow(arrayA: PairNumberArrayType, arrayB: PairNumberArrayType): boolean {\n    const [startA, endA] = arrayA;\n    const [startB, endB] = arrayB;\n\n    return !(endA < startB || endB < startA);\n}\n\nexport function harArrayListOverflow(\n    pairNumberArray: PairNumberArrayType,\n    arrayList: Array<PairNumberArrayType>\n): boolean {\n    for (const arrayInList of arrayList) {\n        if (harArrayOverflow(pairNumberArray, arrayInList)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction getMatchIndexList(html: string, regExp: RegExp): Array<PairNumberArrayType> {\n    const resultList: Array<PairNumberArrayType> = [];\n\n    const matchList = html.match(regExp);\n\n    if (!matchList) {\n        return [];\n    }\n\n    let currentIndex = 0;\n\n    for (const matchedString of matchList) {\n        const start = html.indexOf(matchedString, currentIndex);\n        const end = start + matchedString.length - 1;\n\n        currentIndex = end;\n\n        resultList.push([start, end]);\n    }\n\n    return resultList;\n}\n\nconst tagSelectorRegExpGlobal = /(<\\w+[\\S\\s]*?>)|(<\\/\\w+?>)|(<\\w+[\\S\\s]*?\\/>)/gu;\n\nexport function getTagIndexList(html: string): Array<PairNumberArrayType> {\n    return getMatchIndexList(html, tagSelectorRegExpGlobal);\n}\n\nconst linkSelectorRegExpGlobal = /(<a\\s*?>[\\S\\s]*?<\\/a>)|(<a\\s[\\S\\s]*?>[\\S\\s]*?<\\/a>)|(<a\\s+[\\S\\s]*?\\/>)/gu;\n\nexport function getLinkIndexList(html: string): Array<PairNumberArrayType> {\n    return getMatchIndexList(html, linkSelectorRegExpGlobal);\n}\n","import {mailPrefix} from \"../markdown-const\";\nimport {getLinkIndexList, getTagIndexList, harArrayListOverflow, type PairNumberArrayType} from \"./render-util\";\n\nconst linkTextRegExpGlobal = /(\\w+:\\/\\/[\\w.]+\\.\\w+[\\w+/]*)/giu;\nconst mailTextRegExpGlobal = /([\\w.-]+@[\\w.]+\\.\\w+[\\w+/]*)/giu;\n\nfunction linkReplacer(html: string, replacer: Readonly<RegExp>, hrefPrefix: string): string {\n    const linkPairIndexList = getLinkIndexList(html);\n    const tagIndexList = getTagIndexList(html);\n\n    return html.replace(replacer, (match: string, brackets1: string, offset: number): string => {\n        const rawLinkIndexArray: PairNumberArrayType = [offset, offset];\n\n        if (harArrayListOverflow(rawLinkIndexArray, tagIndexList)) {\n            return match;\n        }\n\n        if (harArrayListOverflow(rawLinkIndexArray, linkPairIndexList)) {\n            return match;\n        }\n\n        return `<a href=\"${hrefPrefix}${match}\">${match}</a>`;\n    });\n}\n\nexport function makeLinkFromText(html: string): string {\n    return linkReplacer(html, linkTextRegExpGlobal, \"\");\n}\n\nexport function makeMailFromText(html: string): string {\n    return linkReplacer(html, mailTextRegExpGlobal, mailPrefix);\n}\n","import {pairTagSelectorList} from \"../parser/parser-selector\";\nimport type {PairTagSelectorType} from \"../parser/parser-type\";\nimport {getTagIndexList, harArrayOverflow} from \"./render-util\";\n\nexport function getSelectorIndexList(html: string, pairTagSelector: PairTagSelectorType): Array<number> {\n    const {selector, equal} = pairTagSelector;\n\n    const resultList: Array<number> = [];\n    const selectorLength = selector.length;\n\n    if (selectorLength === 0) {\n        // Console.error('Selector is empty string');\n        return resultList;\n    }\n\n    let indexOfSelector: number = html.indexOf(selector, 0);\n\n    while (indexOfSelector !== -1) {\n        const equalSymbolsMatch: Array<string> | null = html.slice(indexOfSelector).match(equal);\n\n        if (!equalSymbolsMatch) {\n            return [];\n        }\n\n        const [equalSymbolLine] = equalSymbolsMatch;\n        const equalSymbolLineLength = equalSymbolLine.length;\n\n        if (equalSymbolLineLength === selectorLength) {\n            resultList.push(indexOfSelector);\n        }\n\n        indexOfSelector = html.indexOf(selector, indexOfSelector + equalSymbolLineLength);\n    }\n\n    if (resultList.length % 2 === 1) {\n        return resultList.slice(0, -1);\n    }\n\n    return resultList;\n}\n\nfunction addPairTag(html: string, pairTagSelector: PairTagSelectorType): string {\n    const {selector, openTag, closeTag} = pairTagSelector;\n    const selectorLength = selector.length;\n\n    if (!html.includes(selector)) {\n        return html;\n    }\n\n    const tagPairIndexList = getTagIndexList(html);\n\n    let selectorIndexList: Array<number> = getSelectorIndexList(html, pairTagSelector);\n\n    // Remove indexes into tags, f.e. - <a href=\"http://ex__am__ple.com\">text</a>\n    selectorIndexList = selectorIndexList.filter((selectorIndex: number): boolean => {\n        for (const tagPairIndex of tagPairIndexList) {\n            const selectorStart = selectorIndex;\n            const selectorEnd = selectorIndex + selectorLength - 1;\n\n            if (harArrayOverflow(tagPairIndex, [selectorStart, selectorEnd])) {\n                return false;\n            }\n        }\n\n        return true;\n    });\n\n    const selectorIndexListLength = selectorIndexList.length;\n\n    if (selectorIndexListLength === 0) {\n        return html;\n    }\n\n    let resultTagPairedList: string = html.slice(0, selectorIndexList[0]);\n\n    for (let selectorIndexInList = 1; selectorIndexInList <= selectorIndexListLength; selectorIndexInList += 1) {\n        const selectorIndex = selectorIndexList[selectorIndexInList];\n        const htmlPart = html.slice(selectorIndexList[selectorIndexInList - 1] + selectorLength, selectorIndex);\n\n        resultTagPairedList += selectorIndexInList % 2 === 1 ? openTag + htmlPart + closeTag : htmlPart;\n    }\n\n    return resultTagPairedList;\n}\n\nexport function makePairTag(html: string): string {\n    let result = html;\n\n    for (const pairTagSelector of pairTagSelectorList) {\n        result = addPairTag(result, pairTagSelector);\n    }\n\n    return result;\n}\n","import {mailPrefix} from \"../markdown-const\";\nimport {makeFootnoteSuper} from \"../parser/footnote/footnote\";\nimport {olNumericType, oLParseDataList} from \"../parser/parser-selector\";\nimport type {DocumentMetaType, LineDataType, OlAttributeType, SelectorType} from \"../parser/parser-type\";\nimport {hasEmailSymbol, hasStringNonEmptySymbols} from \"../parser/util/is\";\nimport {breakLineTag, emptyString, space} from \"./render-const\";\nimport {makeLinkFromText, makeMailFromText} from \"./render-link\";\nimport {makePairTag} from \"./render-pair-tag\";\n\nexport const breakLineRegExp = /\\s*?\\\\$/u;\n\nexport function addBreakLine(line: string): string {\n    return line.replace(breakLineRegExp, \"<br/>\");\n}\n\nexport function removeEndBreakLine(line: string): string {\n    return line.replace(breakLineRegExp, emptyString);\n}\n\nexport function getHasEndBreakLine(lineContent: string, useLineBreak: boolean): boolean {\n    return useLineBreak || breakLineRegExp.test(lineContent);\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction imageReplacer(matchedString: string, alt: unknown, src: string, title: unknown): string {\n    const titleAndOtherAttrValue = hasStringNonEmptySymbols(title) ? ` title=\"${title}\"` : \"\";\n    const altAttrValue = hasStringNonEmptySymbols(alt) ? ` alt=\"${alt}\"` : \"\";\n\n    return `<img loading=\"lazy\" src=\"${src}\"${altAttrValue}${titleAndOtherAttrValue}/>`;\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction imageReplacerVariable(\n    matchedString: string,\n    alt: unknown,\n    srcVariable: string,\n    documentMeta: DocumentMetaType\n): string {\n    const altAttrValue = hasStringNonEmptySymbols(alt) ? ` alt=\"${alt}\"` : \"\";\n    const {variable} = documentMeta;\n\n    if (srcVariable in variable) {\n        return `<img loading=\"lazy\" src=\"${variable[srcVariable].value}\"${altAttrValue}/>`;\n    }\n\n    return `<img loading=\"lazy\" src=\"${srcVariable}\"${altAttrValue}/>`;\n}\n\nconst findImageRegExpGlobal = /!\\[([\\S\\s]*?)\\]\\((\\S+?)(?:\\s+\"([\\S\\s]+?)\")?\\)/gu;\nconst findImageVariableRegExpGlobal = /!\\[([\\S\\s]*?)\\]\\[([\\S\\s]+?)\\]/gu;\n\nexport function makeImage(html: string, documentMeta: DocumentMetaType): string {\n    return html\n\n        .replace(findImageRegExpGlobal, imageReplacer)\n\n        .replace(findImageVariableRegExpGlobal, (matchedString: string, alt: unknown, srcVariable: string): string => {\n            return imageReplacerVariable(matchedString, alt, srcVariable, documentMeta);\n        });\n}\n\nconst findCheckboxCheckedRegExoGlobal = /\\[x\\]/giu;\nconst findCheckboxUncheckedRegExoGlobal = /\\[\\s\\]/gu;\n\nexport function makeCheckbox(html: string): string {\n    return html\n\n        .replace(findCheckboxCheckedRegExoGlobal, '<input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\"/>')\n\n        .replace(findCheckboxUncheckedRegExoGlobal, '<input type=\"checkbox\" disabled=\"disabled\"/>');\n}\n\nexport function isImageListOnly(lineContent: string): boolean {\n    return lineContent.replace(findImageRegExpGlobal, \"\").trim() === emptyString;\n}\n\nconst findMailRegExpGlobal = /\\[([\\S\\s]*?)\\]\\((\\S+?)(?:\\s+\"([\\S\\s]+?)\")?(?:\\s+\"([\\S\\s]+?)\")?\\)/gu;\nconst findLinkRegExpGlobal = /\\[([\\S\\s]*?)\\]\\((\\S+?)(?:\\s+\"([\\S\\s]+?)\")?\\)/gu;\nconst findLinkVariableRegExpGlobal = /\\[([\\S\\s]*?)\\]\\[([\\S\\s]+?)\\]/gu;\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction mailReplacer(matchedString: string, linkText: string, href: string, title: unknown, subject: unknown): string {\n    const titleAttrValue = hasStringNonEmptySymbols(title) ? ` title=\"${title}\"` : \"\";\n    const subjectValue = hasStringNonEmptySymbols(subject) ? `?subject=${subject}` : \"\";\n    const text = linkText.length > 0 ? linkText : href;\n\n    if (hasEmailSymbol(matchedString)) {\n        return `<a href=\"${mailPrefix}${href}${subjectValue}\"${titleAttrValue}>${text}</a>`;\n    }\n\n    // Leave it for link\n    return matchedString;\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction linkReplacer(matchedString: string, linkText: string, href: string, title: unknown): string {\n    const titleAttrValue = hasStringNonEmptySymbols(title) ? ` title=\"${title}\"` : \"\";\n    const text = linkText.length > 0 ? linkText : href;\n\n    return `<a href=\"${href}\"${titleAttrValue}>${text}</a>`;\n}\n\nfunction getMailToPrefix(href: string): string {\n    return hasEmailSymbol(href) ? mailPrefix : \"\";\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction linkReplacerVariable(\n    matchedString: string,\n    linkText: string,\n    hrefVariable: string,\n    documentMeta: DocumentMetaType\n): string {\n    const {variable} = documentMeta;\n\n    if (hrefVariable in variable) {\n        const href = variable[hrefVariable].value;\n        const textVariable = linkText.length > 0 ? linkText : href;\n\n        return `<a href=\"${getMailToPrefix(href)}${href}\">${textVariable}</a>`;\n    }\n\n    const text = linkText.length > 0 ? linkText : hrefVariable;\n\n    return `<a href=\"${getMailToPrefix(hrefVariable)}${hrefVariable}\">${text}</a>`;\n}\n\nfunction defineVariables(html: string, documentMeta: DocumentMetaType): string {\n    return html.replace(\n        findLinkVariableRegExpGlobal,\n        (matchedString: string, linkText: string, hrefVariable: string): string => {\n            return linkReplacerVariable(matchedString, linkText, hrefVariable, documentMeta);\n        }\n    );\n}\n\nexport function makeMail(html: string): string {\n    return html.replace(findMailRegExpGlobal, mailReplacer);\n}\n\nexport function makeLink(html: string): string {\n    return html.replace(findLinkRegExpGlobal, linkReplacer);\n}\n\nexport function getOlTypeBySelector(dataLineSelector: SelectorType): OlAttributeType {\n    for (const oLParseData of oLParseDataList) {\n        const {selector, olAttributeType} = oLParseData;\n\n        if (dataLineSelector === selector) {\n            return olAttributeType;\n        }\n    }\n\n    // Console.error('Can not detect ol type by selector', dataLineSelector);\n\n    return olNumericType;\n}\n\nexport function getOlStart(trimmedLine: string): string {\n    const dotIndex = trimmedLine.indexOf(\".\");\n\n    return trimmedLine.slice(0, dotIndex);\n}\n\nexport function renderAdditionalLineList(lineData: LineDataType): string {\n    const {additionalLineList, config} = lineData;\n    const {lineContent} = lineData;\n    const {useLineBreak} = config;\n\n    if (additionalLineList.length === 0) {\n        return emptyString;\n    }\n\n    const hasParentEndBreakLine = getHasEndBreakLine(lineContent, useLineBreak);\n    const prefix = hasParentEndBreakLine ? breakLineTag : space;\n    const additionalLineListLength = additionalLineList.length;\n    const additionalLineLastIndex = additionalLineListLength - 1;\n    const lineResult: Array<string> = Array.from<string>({length: additionalLineListLength}).fill(\"\");\n\n    for (let lineIndex = 0; lineIndex < additionalLineListLength; lineIndex += 1) {\n        const additionalLine = additionalLineList[lineIndex];\n        const hasBreakLine = getHasEndBreakLine(additionalLine, useLineBreak);\n\n        if (hasBreakLine) {\n            const additionalLineWithoutBreakLine = additionalLine.replace(breakLineRegExp, emptyString);\n\n            lineResult[lineIndex] =\n                lineIndex === additionalLineLastIndex\n                    ? additionalLineWithoutBreakLine\n                    : additionalLineWithoutBreakLine + breakLineTag;\n        } else {\n            lineResult[lineIndex] = lineIndex === additionalLineLastIndex ? additionalLine : additionalLine + space;\n        }\n    }\n\n    return prefix + lineResult.join(emptyString);\n}\n\nexport function renderInlineHtml(html: string, documentMeta: DocumentMetaType): string {\n    const {config} = documentMeta;\n    const {parseLink} = config;\n\n    let fullLineContent = makeFootnoteSuper(html, documentMeta);\n\n    fullLineContent = makeImage(fullLineContent, documentMeta);\n\n    fullLineContent = makeMail(fullLineContent);\n    if (parseLink) {\n        fullLineContent = makeMailFromText(fullLineContent);\n    }\n\n    fullLineContent = makeLink(fullLineContent);\n    if (parseLink) {\n        fullLineContent = makeLinkFromText(fullLineContent);\n    }\n\n    fullLineContent = defineVariables(fullLineContent, documentMeta);\n\n    fullLineContent = makeCheckbox(fullLineContent);\n    return makePairTag(fullLineContent);\n}\n","import type {CellAlignType, CellTagNameType} from \"./render-table-type\";\n\nexport const cellAlignTypeMap: Record<string, CellAlignType> = {\n    center: \"center\",\n    \"default\": \"left\",\n    left: \"left\",\n    right: \"right\",\n};\n\nexport const cellTagNameTypeMap: Record<string, CellTagNameType> = {\n    tdCell: \"td\",\n    thCell: \"th\",\n};\n","import type {DocumentMetaType, SelectorType} from \"../../parser/parser-type\";\nimport {filterEmptyString} from \"../../parser/util/string\";\nimport {emptyString} from \"../render-const\";\nimport {renderInlineHtml} from \"../render-helper\";\nimport {cellAlignTypeMap} from \"./render-table-const\";\nimport type {CellAlignType} from \"./render-table-type\";\n\nexport function renderTableCellContent(line: string, documentMeta: DocumentMetaType): string {\n    return renderInlineHtml(line, documentMeta).trim();\n}\n\nexport function isTableDivideLine(line: string): boolean {\n    return line.replace(/[\\s:|-]/gu, \"\") === emptyString;\n}\n\nexport function lineToAlign(divideRaw: string): CellAlignType {\n    const alignMark = \":\";\n    const divide: string = divideRaw.trim();\n\n    const divideCharList: Array<string> = divide.split(\"\");\n    const [firstChar] = divideCharList;\n\n    const lastChar = divide[divide.length - 1];\n\n    if (firstChar === lastChar && firstChar === alignMark) {\n        return cellAlignTypeMap.center;\n    }\n\n    if (lastChar === alignMark) {\n        return cellAlignTypeMap.right;\n    }\n\n    return cellAlignTypeMap.left;\n}\n\nexport function getAlignList(selector: SelectorType, divideLine: string): Array<CellAlignType> {\n    return divideLine.split(selector).filter(filterEmptyString).map<CellAlignType>(lineToAlign);\n}\n","import type {DocumentMetaType, LineDataType} from \"../../parser/parser-type\";\nimport {filterEmptyString} from \"../../parser/util/string\";\nimport {emptyString} from \"../render-const\";\nimport {cellAlignTypeMap, cellTagNameTypeMap} from \"./render-table-const\";\nimport {getAlignList, isTableDivideLine, renderTableCellContent} from \"./render-table-helper\";\nimport type {CellAlignType, CellTagNameType} from \"./render-table-type\";\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction renderTableRow(\n    lineData: LineDataType,\n    line: string,\n    alignList: Array<CellAlignType>,\n    cellName: CellTagNameType,\n    documentMeta: DocumentMetaType\n): string {\n    const {selector} = lineData;\n\n    return line\n        .split(selector)\n        .filter(filterEmptyString)\n        .map((cellContent: string, cellIndex: number): string => {\n            const align = alignList[cellIndex] || cellAlignTypeMap.default;\n\n            return `<${cellName} align=\"${align}\">${renderTableCellContent(cellContent, documentMeta)}</${cellName}>`;\n        })\n        .join(emptyString);\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction renderTableRowList(\n    lineData: LineDataType,\n    lineList: Array<string>,\n    alignList: Array<CellAlignType>,\n    cellName: CellTagNameType,\n    documentMeta: DocumentMetaType\n): string {\n    return lineList\n        .map((line: string): string => {\n            return `<tr>${renderTableRow(lineData, line, alignList, cellName, documentMeta)}</tr>`;\n        })\n        .join(emptyString);\n}\n\nexport function renderTable(lineData: LineDataType, documentMeta: DocumentMetaType): string {\n    const {selector, additionalLineList, line} = lineData;\n\n    const lineList = [line, ...additionalLineList];\n\n    const dividerLine = lineList.find(isTableDivideLine);\n\n    // eslint-disable-next-line no-undefined\n    if (dividerLine === undefined) {\n        const bodyOnlyContent = renderTableRowList(lineData, lineList, [], cellTagNameTypeMap.tdCell, documentMeta);\n\n        return `<table><tbody>${bodyOnlyContent}</tbody></table>`;\n    }\n\n    const dividerLineIndex = lineList.indexOf(dividerLine);\n    const headLineList = lineList.slice(0, dividerLineIndex);\n    const bodyLineList = lineList.slice(dividerLineIndex + 1);\n    const alignList = getAlignList(selector, dividerLine);\n\n    const headContent = renderTableRowList(lineData, headLineList, alignList, cellTagNameTypeMap.thCell, documentMeta);\n    const bodyContent = renderTableRowList(lineData, bodyLineList, alignList, cellTagNameTypeMap.tdCell, documentMeta);\n\n    return `<table><thead>${headContent}</thead><tbody>${bodyContent}</tbody></table>`;\n}\n","import {getIsFootnoteDescription} from \"../parser/footnote/footnote-helper\";\nimport type {DocumentMetaType, LineDataType} from \"../parser/parser-type\";\nimport {\n    getIsBlockquote,\n    getIsCode,\n    getIsHeader,\n    getIsLine,\n    getIsOlItem,\n    getIsStartWithHtml,\n    getIsTable,\n    getIsUlItem,\n} from \"../parser/util/is-tag\";\nimport {getIsEdgeLine} from \"../parser/util/navigation\";\nimport {emptyString} from \"./render-const\";\n// Import {makeFootnoteSuper} from '../parser/footnote/footnote';\nimport {\n    addBreakLine,\n    getOlStart,\n    getOlTypeBySelector,\n    isImageListOnly,\n    removeEndBreakLine,\n    renderAdditionalLineList,\n    renderInlineHtml,\n} from \"./render-helper\";\nimport {renderTable} from \"./render-table/render-table\";\n\nexport function renderChildList(lineDataList: Array<LineDataType>, documentMeta: DocumentMetaType): string {\n    return lineDataList\n        .map((lineData: LineDataType, lineDataIndex: number): string => {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return renderLineData(lineData, lineDataIndex, lineDataList, documentMeta);\n        })\n        .map(addBreakLine)\n        .join(emptyString);\n}\n\n// eslint-disable-next-line max-statements, @typescript-eslint/max-params\nexport function renderLineData(\n    lineData: LineDataType,\n    lineDataIndex: number,\n    lineDataList: Array<LineDataType>,\n    documentMeta: DocumentMetaType\n): string {\n    const {selector, childList, lineContent, trimmedLine, additionalLineList, config} = lineData;\n    const {codeHighlight} = config;\n    const additionLineListRender = renderAdditionalLineList(lineData);\n    const childListRender = renderChildList(childList, documentMeta);\n\n    let fullLineContent = removeEndBreakLine(lineContent) + additionLineListRender;\n\n    fullLineContent = renderInlineHtml(fullLineContent, documentMeta);\n\n    fullLineContent += childListRender;\n\n    if (getIsFootnoteDescription(lineContent)) {\n        return \"\";\n    }\n\n    if (getIsLine(lineData)) {\n        return \"<hr/>\";\n    }\n\n    if (getIsTable(lineData)) {\n        return renderTable(lineData, documentMeta);\n    }\n\n    if (getIsCode(lineData)) {\n        const codeText = codeHighlight(lineContent, additionalLineList.join(\"\\n\"));\n\n        return lineContent ? `<code data-lang=\"${lineContent}\">${codeText}</code>` : `<code>${codeText}</code>`;\n    }\n\n    if (lineContent === emptyString && childList.length === 0) {\n        return emptyString;\n    }\n\n    if (getIsHeader(lineData)) {\n        const headerTag = selector.length - 1;\n\n        return `<h${headerTag}>${fullLineContent}</h${headerTag}>`;\n    }\n\n    if (getIsBlockquote(lineData)) {\n        return `<blockquote>${fullLineContent}</blockquote>`;\n    }\n\n    if (getIsUlItem(lineData)) {\n        const isFirstItem = getIsEdgeLine(lineData, lineDataList, -1);\n        const isLastItem = getIsEdgeLine(lineData, lineDataList, 1);\n        const prefix = isFirstItem ? \"<ul>\" : \"\";\n        const postfix = isLastItem ? \"</ul>\" : \"\";\n\n        return `${prefix}<li>${fullLineContent}</li>${postfix}`;\n    }\n\n    if (getIsOlItem(lineData)) {\n        const isFirstItem = getIsEdgeLine(lineData, lineDataList, -1);\n        const isLastItem = getIsEdgeLine(lineData, lineDataList, 1);\n        const {selector: lineDataSelector} = lineData;\n        const prefix = isFirstItem\n            ? `<ol type=\"${getOlTypeBySelector(lineDataSelector)}\" start=\"${getOlStart(trimmedLine)}\">`\n            : \"\";\n        const postfix = isLastItem ? \"</ol>\" : \"\";\n\n        return `${prefix}<li>${fullLineContent}</li>${postfix}`;\n    }\n\n    if (lineContent === emptyString || getIsStartWithHtml(lineData) || isImageListOnly(lineContent)) {\n        return fullLineContent;\n    }\n\n    return `<p>${fullLineContent}</p>`;\n}\n","import type {MarkdownConfigShallowType, MarkdownConfigType} from \"../library\";\nimport {getFullWrapperClassName} from \"./helper\";\nimport {defaultMarkdownConfig} from \"./markdown-const\";\nimport {getMdFootnoteContent} from \"./parser/footnote/footnote-helper\";\nimport {parseLine} from \"./parser/parse-line\";\nimport type {DocumentMetaType, FootnoteType, LineDataType} from \"./parser/parser-type\";\nimport {renderChildList} from \"./render/render\";\nimport {emptyString} from \"./render/render-const\";\n\nexport function markdown(mdInput: string, config: MarkdownConfigShallowType = defaultMarkdownConfig): string {\n    const markdownConfig: MarkdownConfigType = {\n        ...defaultMarkdownConfig,\n        ...config,\n    };\n\n    const {useWrapper} = markdownConfig;\n\n    const markdownFootnoteConfig: MarkdownConfigType = {\n        ...defaultMarkdownConfig,\n        ...config,\n        useWrapper: false,\n    };\n\n    const mainParent: LineDataType = {\n        additionalLineList: [],\n        childList: [],\n        config: markdownConfig,\n        line: emptyString,\n        lineContent: \"\",\n        lineIndex: -1,\n        selector: emptyString,\n        spaceCount: -1,\n        trimmedLine: \"\",\n    };\n    const structuredLineDataList: Array<LineDataType> = [mainParent];\n    const savedLineDataList: Array<LineDataType> = [mainParent];\n    const documentMeta: DocumentMetaType = {\n        codeLineData: null,\n        config: markdownConfig,\n        footnoteList: [],\n        tableLineData: null,\n        variable: {},\n    };\n\n    mdInput.split(\"\\n\").forEach((line: string, lineIndex: number, allLineList: ReadonlyArray<string>) => {\n        parseLine(line, lineIndex, allLineList, structuredLineDataList, savedLineDataList, documentMeta);\n    });\n\n    const mainContent = renderChildList(structuredLineDataList, documentMeta);\n\n    const footnoteDescriptionList: Array<string> = documentMeta.footnoteList.map((footnote: FootnoteType): string => {\n        const {id} = footnote;\n        const mdFootnoteContent = getMdFootnoteContent(footnote);\n\n        return `<li id=\"${id}\">${markdown(mdFootnoteContent, markdownFootnoteConfig)}</li>`;\n    });\n\n    const footnoteDescriptionHtml: string =\n        footnoteDescriptionList.length === 0\n            ? \"\"\n            : [\"<hr/>\", '<ol type=\"1\">', ...footnoteDescriptionList, \"</ol>\"].join(\"\");\n\n    const fullContent = [mainContent, footnoteDescriptionHtml].join(\"\");\n\n    if (!useWrapper) {\n        return fullContent;\n    }\n\n    const fullWrapperClassName: string = getFullWrapperClassName(markdownConfig);\n\n    return `<div class=\"${fullWrapperClassName}\">${fullContent}</div>`;\n}\n","import {emptyString} from \"../render/render-const\";\nimport {addLineData, fromToFootnoteList, getFootnoteList} from \"./footnote/footnote\";\nimport {getIsFootnoteDescription} from \"./footnote/footnote-helper\";\nimport {oLParseDataList, selectorCodeList, selectorLineList, selectorList, selectorTableList} from \"./parser-selector\";\nimport type {DocumentMetaType, LineDataType, ShortLineInfoType} from \"./parser-type\";\nimport {getParent} from \"./util/navigation\";\nimport {cleanLine, getIsAllSymbolsEqual} from \"./util/string\";\nimport {getVariableData} from \"./util/variable\";\n\nfunction getShortInfo(trimmedLine: string): ShortLineInfoType {\n    for (const selector of selectorList) {\n        if (trimmedLine.startsWith(selector)) {\n            return {\n                lineContent: cleanLine(trimmedLine.replace(selector, emptyString)),\n                selector,\n            };\n        }\n    }\n\n    for (const lineSelector of selectorLineList) {\n        if (trimmedLine.startsWith(lineSelector) && getIsAllSymbolsEqual(trimmedLine)) {\n            return {\n                lineContent: emptyString,\n                selector: lineSelector,\n            };\n        }\n    }\n\n    for (const oLParseData of oLParseDataList) {\n        const {selector, regExpSearchSelector} = oLParseData;\n\n        if (trimmedLine.search(regExpSearchSelector) === 0) {\n            return {\n                lineContent: cleanLine(trimmedLine.replace(regExpSearchSelector, emptyString)),\n                selector,\n            };\n        }\n    }\n\n    return {\n        lineContent: cleanLine(trimmedLine),\n        selector: emptyString,\n    };\n}\n\n// eslint-disable-next-line complexity, max-params, max-statements, @typescript-eslint/max-params\nexport function parseLine(\n    line: string,\n    lineIndex: number,\n    allLineList: ReadonlyArray<string>,\n    structuredLineDataList: ReadonlyArray<LineDataType>,\n    savedLineDataList: Array<LineDataType>,\n    documentMeta: DocumentMetaType\n): boolean {\n    const trimmedLine = line.trim();\n    const isEmptyString = trimmedLine === emptyString;\n    const rawSpaceCount = isEmptyString\n        ? savedLineDataList[savedLineDataList.length - 1].spaceCount\n        : line.search(/\\S/u);\n    const spaceCount = Math.max(0, rawSpaceCount);\n    const defaultSelectorData: ShortLineInfoType = {\n        lineContent: emptyString,\n        selector: emptyString,\n    };\n\n    const {selector, lineContent} = isEmptyString ? defaultSelectorData : getShortInfo(trimmedLine);\n\n    const lineData: LineDataType = {\n        additionalLineList: [],\n        childList: [],\n        config: documentMeta.config,\n        line: isEmptyString ? emptyString : line,\n        lineContent,\n        lineIndex,\n        selector,\n        spaceCount,\n        trimmedLine,\n    };\n\n    if (selectorCodeList.includes(selector)) {\n        if (documentMeta.codeLineData && lineContent === emptyString) {\n            documentMeta.codeLineData = null;\n            return true;\n        }\n\n        documentMeta.codeLineData = lineData;\n    }\n\n    const {codeLineData} = documentMeta;\n\n    if (codeLineData && codeLineData !== lineData) {\n        codeLineData.additionalLineList.push(lineData.line);\n        return true;\n    }\n\n    const updatedFootnoteList = getFootnoteList(lineContent);\n    const {footnoteList, tableLineData, variable} = documentMeta;\n\n    fromToFootnoteList(updatedFootnoteList, footnoteList);\n\n    if (selectorTableList.includes(selector)) {\n        if (tableLineData) {\n            // Append new line in current block\n\n            tableLineData.additionalLineList.push(lineData.line);\n            return true;\n        }\n        // Create new block\n\n        documentMeta.tableLineData = lineData;\n    } else {\n        // Close table block\n\n        documentMeta.tableLineData = null;\n    }\n\n    const variableData = getVariableData(lineContent);\n\n    if (lineData.selector === emptyString && lineContent.length > 0) {\n        const prevItemIndex = savedLineDataList.length - 1;\n        const prevItem = savedLineDataList.at(prevItemIndex);\n        const isTable = Boolean(prevItem && selectorTableList.includes(prevItem.selector));\n\n        if (variableData) {\n            variable[variableData.key] = variableData;\n        }\n\n        if (prevItem && prevItem.lineContent.length > 0 && !isTable && !variableData) {\n            prevItem.additionalLineList.push(lineContent);\n            return true;\n        }\n    }\n\n    const parentLineData = getParent(lineData, savedLineDataList);\n\n    if (!parentLineData) {\n        // Console.error('Parent not found');\n        return false;\n    }\n\n    if (variableData) {\n        return true;\n    }\n\n    parentLineData.childList.push(lineData);\n    savedLineDataList.push(lineData);\n\n    if (getIsFootnoteDescription(lineContent)) {\n        addLineData(lineData, footnoteList);\n    }\n\n    return true;\n}\n","import type {VariableType} from \"../parser-type\";\n\nexport function getVariableData(lineContent: string): VariableType | null {\n    const matchData = /\\[([^^][\\S\\s]+?)\\]:\\s+?\\S/u.exec(lineContent);\n\n    if (!matchData) {\n        return null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/prefer-destructuring\n    const key = matchData[1];\n\n    const value = lineContent.slice(lineContent.indexOf(\"]:\") + 3).trim();\n\n    return {\n        key,\n        value,\n    };\n}\n","import type {MarkdownConfigType} from \"../library\";\nimport {defaultMarkdownConfig,themeClassNameMap} from \"./markdown-const\";\n\nexport function getFullWrapperClassName(markdownConfig: MarkdownConfigType): string {\n    const {wrapperClassName: wrapperClassNameConfig, themeName} = markdownConfig;\n    const {wrapperClassName: wrapperClassNameDefault} = defaultMarkdownConfig;\n\n    const wrapperClassName: string =\n        wrapperClassNameConfig === wrapperClassNameDefault\n            ? wrapperClassNameDefault\n            : `${wrapperClassNameDefault} ${wrapperClassNameConfig}`;\n\n    const themeClassName: string = themeClassNameMap[themeName];\n\n    return `${wrapperClassName} ${themeClassName}`;\n}\n","import \"./src/markdown.scss\";\n\nimport {defaultMarkdownConfig, type ThemeNameEnum} from \"./src/markdown-const\";\n\nexport {markdown as default,markdown} from \"./src/markdown\";\nexport {defaultMarkdownConfig, ThemeNameEnum} from \"./src/markdown-const\";\n\nexport const classNameMdProThemeDark = \"md-pro-theme-dark\";\nexport const classNameMdProThemeLight = \"md-pro-theme-light\";\nexport const classNameMdPro: string = defaultMarkdownConfig.wrapperClassName;\n\nexport type MarkdownConfigType = Readonly<{\n    // Code highlight\n    codeHighlight: (langName: string, code: string) => string;\n    // https://exmaple.com -> <a href=\"https://exmaple.com\">https://exmaple.com</a>\n    parseLink: boolean;\n    // The themeName: light | dark | auto (auto - will use current system theme i.e. light or dark), needed class will be added to the wrapper div\n    themeName: ThemeNameEnum;\n    // Make \\n => <br/>\n    useLineBreak: boolean;\n    // Use wrapper <div class=\"md-pro\">...</div>\n    useWrapper: boolean;\n    // Additional css class for wrapper\n    wrapperClassName: string;\n}>;\n\nexport type MarkdownConfigShallowType = Readonly<Partial<MarkdownConfigType>>;\n"],"names":["ThemeNameEnum","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","defaultMarkdownConfig","codeHighlight","langName","code","parseLink","themeName","auto","useLineBreak","useWrapper","wrapperClassName","themeClassNameMap","dark","light","mailPrefix","getIsFootnoteDescription","lineContent","test","getFootnoteById","id","list","find","footnote","getFootnoteInlineLineContent","match","slice","trim","getFootnoteMarkId","toLowerCase","replace","emptyString","space","breakLineTag","footnoteTypeMap","inline","findFootnoteMarkGlobalRegExp","matchToFootnote","inlineLineContent","indexOf","descriptionLineData","type","super","selectorHeaderList","selectorBlockquoteList","selectorLineList","selectorTableList","selectorCodeList","selectorULItemList","olNumericType","oLParseDataList","olAttributeType","regExpSearchSelector","selector","selectorList","sort","itemA","itemB","length","pairTagSelectorList","closeTag","equal","openTag","searchSiblingItem","lineData","lineDataList","direction","index","siblingIndex","siblingItem","trimmedLine","getIsEdgeLine","foundItem","filterEmptyString","line","cleanLine","getIsAllSymbolsEqual","charList","split","firstSymbol","char","htmlPairTag","htmlSingleTag","hasStringNonEmptySymbols","hasEmailSymbol","includes","harArrayOverflow","arrayA","arrayB","startA","endA","startB","endB","harArrayListOverflow","pairNumberArray","arrayList","arrayInList","getMatchIndexList","html","regExp","resultList","matchList","currentIndex","matchedString","start","end","push","tagSelectorRegExpGlobal","getTagIndexList","linkSelectorRegExpGlobal","linkTextRegExpGlobal","mailTextRegExpGlobal","linkReplacer","replacer","hrefPrefix","linkPairIndexList","getLinkIndexList","tagIndexList","brackets1","offset","rawLinkIndexArray","addPairTag","pairTagSelector","selectorLength","tagPairIndexList","selectorIndexList","indexOfSelector","equalSymbolsMatch","equalSymbolLine","equalSymbolLineLength","getSelectorIndexList","filter","selectorIndex","tagPairIndex","selectorIndexListLength","resultTagPairedList","selectorIndexInList","htmlPart","breakLineRegExp","addBreakLine","getHasEndBreakLine","imageReplacer","alt","src","title","titleAndOtherAttrValue","findImageRegExpGlobal","findImageVariableRegExpGlobal","findCheckboxCheckedRegExoGlobal","findCheckboxUncheckedRegExoGlobal","findMailRegExpGlobal","findLinkRegExpGlobal","findLinkVariableRegExpGlobal","mailReplacer","linkText","href","subject","titleAttrValue","subjectValue","text","getMailToPrefix","renderInlineHtml","documentMeta","config","fullLineContent","firstLetter","footnoteList","makeFootnoteSuper","srcVariable","altAttrValue","variable","imageReplacerVariable","makeImage","makeMail","makeMailFromText","makeLink","makeLinkFromText","hrefVariable","textVariable","linkReplacerVariable","defineVariables","makeCheckbox","result","makePairTag","cellAlignTypeMap","center","left","right","cellTagNameTypeMap","tdCell","thCell","isTableDivideLine","lineToAlign","divideRaw","divide","divideCharList","firstChar","lastChar","renderTableRowList","lineList","alignList","cellName","map","cellContent","cellIndex","align","default","renderTableCellContent","join","renderTableRow","renderChildList","lineDataIndex","childList","additionalLineList","additionLineListRender","prefix","additionalLineListLength","additionalLineLastIndex","lineResult","Array","from","fill","lineIndex","additionalLine","additionalLineWithoutBreakLine","renderAdditionalLineList","childListRender","getIsLine","getIsTable","dividerLine","undefined","dividerLineIndex","headLineList","bodyLineList","divideLine","getAlignList","renderTable","getIsCode","codeText","getIsHeader","headerTag","getIsBlockquote","getIsUlItem","oLParseData","getIsOlItem","isFirstItem","isLastItem","lineDataSelector","dataLineSelector","getOlTypeBySelector","dotIndex","getOlStart","search","getIsStartWithHtml","isImageListOnly","renderLineData","markdown","mdInput","markdownConfig","markdownFootnoteConfig","mainParent","spaceCount","structuredLineDataList","savedLineDataList","codeLineData","tableLineData","forEach","allLineList","isEmptyString","rawSpaceCount","Math","max","defaultSelectorData","startsWith","lineSelector","getShortInfo","updatedFootnoteList","matchedList","getFootnoteList","fromList","toList","fromItem","candidateToExtend","toItem","fromToFootnoteList","variableData","matchData","exec","getVariableData","prevItemIndex","prevItem","at","isTable","Boolean","parentLineData","lineDataCandidate","getParent","rawMatchId","rawId","addLineData","parseLine","mainContent","footnoteDescriptionList","mdFootnoteContent","getMdFootnoteContent","fullContent","fullWrapperClassName","wrapperClassNameConfig","wrapperClassNameDefault","getFullWrapperClassName","classNameMdProThemeDark","classNameMdProThemeLight","classNameMdPro"],"sourceRoot":""}